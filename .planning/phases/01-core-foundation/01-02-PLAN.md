---
phase: 01-core-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/pty/manager.ts
autonomous: true

must_haves:
  truths:
    - "PTY spawns Claude Code CLI process successfully"
    - "All output from Claude Code streams to onData callback in real-time"
    - "Text can be injected into PTY via write() method"
    - "Process exit is detected with correct exit code"
    - "Resources are cleaned up on termination without leaks"
  artifacts:
    - src/pty/manager.ts
  key_links:
    - "PTYManager implements PTYManager interface from types"
    - "Uses Bun.spawn with terminal option (not stdout/stderr)"
    - "proc.exited promise used for exit handling (not terminal.exit callback)"
---

<objective>
Implement PTYManager class that spawns and controls Claude Code in a pseudo-terminal using Bun's Terminal API.

Purpose: This is the core PTY infrastructure. All output capture, input injection, and lifecycle management for Claude Code flows through this class.

Output: Fully functional PTYManager that satisfies PTY-01 through PTY-05 requirements.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-foundation/01-RESEARCH.md
@src/pty/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PTYManager class</name>
  <files>src/pty/manager.ts</files>
  <action>
    Implement PTYManager following the Pattern 1 from research:

    ```typescript
    import type { Subprocess, Terminal } from "bun";
    import type { PTYManagerOptions, PTYManager as IPTYManager } from "./types";

    export class PTYManager implements IPTYManager {
      private proc: Subprocess | null = null;
      private terminal: Terminal | null = null;
      private _exitCode: number | null = null;

      async spawn(options: PTYManagerOptions): Promise<void> {
        if (this.proc) {
          throw new Error("PTY already running. Call cleanup() first.");
        }

        this.proc = Bun.spawn(options.command, {
          terminal: {
            cols: options.cols ?? 120,
            rows: options.rows ?? 40,
            data: (terminal, data) => {
              options.onData(data);
            },
          },
          env: {
            ...process.env,
            TERM: "xterm-256color",
            COLORTERM: "truecolor",
          },
        });

        this.terminal = this.proc.terminal ?? null;

        // Handle actual process exit via proc.exited promise
        // (NOT the terminal.exit callback which is for PTY lifecycle)
        this.proc.exited.then((exitCode) => {
          this._exitCode = exitCode;
          options.onExit(exitCode, this.proc?.signalCode ?? null);
        });
      }

      write(data: string): void {
        if (!this.terminal) {
          throw new Error("PTY not initialized");
        }
        if (this.terminal.closed) {
          throw new Error("Cannot write to closed terminal");
        }
        this.terminal.write(data);
      }

      async cleanup(): Promise<void> {
        if (this.proc && !this.proc.killed) {
          this.proc.kill("SIGTERM");
          // Wait for process to actually exit
          await this.proc.exited;
        }
        if (this.terminal && !this.terminal.closed) {
          this.terminal.close();
        }
        this.proc = null;
        this.terminal = null;
      }

      get isRunning(): boolean {
        return this.proc !== null && !this.proc.killed;
      }

      get exitCode(): number | null {
        return this._exitCode;
      }
    }
    ```

    Key implementation notes from research:
    - Use `terminal` option, NOT stdout/stderr (they are null with terminal mode)
    - Use `proc.exited` promise for exit handling, not terminal exit callback
    - Set TERM and COLORTERM env vars for proper terminal behavior
    - Check `terminal.closed` before writing
    - Default to 120x40 for comfortable viewing
  </action>
  <verify>
    bun run typecheck
    grep -l "Bun.spawn" src/pty/manager.ts
    grep -l "proc.exited" src/pty/manager.ts
  </verify>
  <done>
    - PTYManager class exists and implements IPTYManager interface
    - Uses Bun.spawn with terminal option
    - Uses proc.exited for process exit (not terminal.exit)
    - write() checks for closed terminal
    - cleanup() kills process and closes terminal
    - Type check passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PTY module index export</name>
  <files>src/pty/index.ts</files>
  <action>
    Create index file for clean imports:

    ```typescript
    export { PTYManager } from "./manager";
    export * from "./types";
    ```
  </action>
  <verify>
    bun run typecheck
    grep "PTYManager" src/pty/index.ts
  </verify>
  <done>
    - src/pty/index.ts exports PTYManager class and types
    - Can import as `import { PTYManager } from "./pty"`
  </done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# Type check passes
bun run typecheck

# PTYManager file exists with key patterns
grep -l "Bun.spawn" src/pty/manager.ts
grep -l "terminal:" src/pty/manager.ts
grep -l "proc.exited" src/pty/manager.ts

# Module exports work
echo "import { PTYManager } from './src/pty';" | bun run -
```
</verification>

<success_criteria>
1. `bun run typecheck` passes
2. PTYManager class implements all interface methods
3. Uses Bun.Terminal API correctly (terminal option, not stdout/stderr)
4. Exit handling uses proc.exited promise
5. Environment variables set correctly (TERM, COLORTERM)
6. Defensive checks: throws on write to closed terminal, throws on double spawn
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-foundation/01-02-SUMMARY.md`
</output>
