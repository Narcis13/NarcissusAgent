---
phase: 01-core-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/index.ts
autonomous: false

must_haves:
  truths:
    - "Running `bun run src/index.ts 'test task'` spawns Claude Code in PTY"
    - "Terminal output streams to stdout in real-time with colors preserved"
    - "Session state transitions from idle to task_running on start"
    - "Process exit is detected and reported with exit code"
    - "Ctrl+C triggers graceful shutdown with cleanup"
    - "GET /api/session returns current session info"
  artifacts:
    - src/index.ts
  key_links:
    - "CLI imports PTYManager from ./pty"
    - "CLI imports sessionManager from ./session"
    - "CLI imports createServer from ./server"
    - "SIGINT/SIGTERM handlers call ptyManager.cleanup()"
---

<objective>
Create CLI entry point that wires PTYManager, SessionManager, and Hono server together into a working application.

Purpose: This is the integration point where all components come together. After this plan, `cco "task"` will spawn Claude Code and stream output while tracking session state.

Output: Working CLI that satisfies LOOP-01 and demonstrates all Phase 1 requirements working together.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-foundation/01-RESEARCH.md
@.planning/phases/01-core-foundation/01-02-SUMMARY.md
@.planning/phases/01-core-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI entry point with integration</name>
  <files>src/index.ts</files>
  <action>
    Create the main CLI entry point that:
    1. Parses CLI arguments (task description)
    2. Starts Hono server
    3. Initializes PTYManager with output streaming
    4. Tracks session state
    5. Handles graceful shutdown

    ```typescript
    #!/usr/bin/env bun
    import { parseArgs } from "util";
    import { PTYManager } from "./pty";
    import { sessionManager } from "./session";
    import { createServer } from "./server";

    // Parse CLI arguments
    const { values, positionals } = parseArgs({
      args: Bun.argv.slice(2),
      options: {
        port: { type: "string", default: "3000" },
        help: { type: "boolean", short: "h" },
      },
      strict: true,
      allowPositionals: true,
    });

    // Show help
    if (values.help || positionals.length === 0) {
      console.log(`
Claude Code Orchestrator (CCO)

Usage: cco <task description> [options]

Options:
  --port <number>  Server port (default: 3000)
  -h, --help       Show this help message

Examples:
  cco "build a hello world app"
  cco "fix the bug in auth" --port 4000
`);
      process.exit(values.help ? 0 : 1);
    }

    const taskDescription = positionals.join(" ");
    const port = parseInt(values.port ?? "3000", 10);

    // Create PTY manager
    const ptyManager = new PTYManager();

    // Text decoder for output
    const decoder = new TextDecoder();

    // Graceful shutdown handler
    async function shutdown(signal: string) {
      console.log(`\n[CCO] Received ${signal}, shutting down...`);

      try {
        await ptyManager.cleanup();
        sessionManager.setIdle();
        console.log("[CCO] Cleanup complete");
      } catch (error) {
        console.error("[CCO] Cleanup error:", error);
      }

      process.exit(0);
    }

    // Register signal handlers
    process.on("SIGINT", () => shutdown("SIGINT"));
    process.on("SIGTERM", () => shutdown("SIGTERM"));

    // Main function
    async function main() {
      console.log(`[CCO] Starting Claude Code Orchestrator`);
      console.log(`[CCO] Task: ${taskDescription}`);
      console.log(`[CCO] Server: http://localhost:${port}`);
      console.log(`[CCO] Session API: http://localhost:${port}/api/session`);
      console.log("");

      // Start HTTP server
      const server = Bun.serve(createServer(port));
      console.log(`[CCO] Server running on port ${port}`);

      // Start session
      sessionManager.startTask(taskDescription);
      console.log(`[CCO] Session state: ${sessionManager.getState().status}`);
      console.log("");
      console.log("--- Claude Code Output ---");
      console.log("");

      // Spawn Claude Code with the task
      try {
        await ptyManager.spawn({
          command: ["claude", taskDescription],
          onData: (data) => {
            // Stream output to stdout (preserves ANSI colors)
            process.stdout.write(decoder.decode(data));
          },
          onExit: (exitCode, signalCode) => {
            console.log("");
            console.log("--- End Claude Code Output ---");
            console.log("");
            console.log(`[CCO] Claude Code exited with code: ${exitCode}`);
            if (signalCode) {
              console.log(`[CCO] Signal: ${signalCode}`);
            }

            // Update session state
            sessionManager.setIdle();
            console.log(`[CCO] Session state: ${sessionManager.getState().status}`);

            // Report runtime
            const metadata = sessionManager.getMetadata();
            if (metadata) {
              console.log(`[CCO] Runtime: ${formatRuntime(metadata.runtime)}`);
            }

            // Exit with Claude's exit code
            process.exit(exitCode ?? 0);
          },
          cols: 120,
          rows: 40,
        });
      } catch (error) {
        console.error("[CCO] Failed to spawn Claude Code:", error);
        sessionManager.setError(String(error));
        process.exit(1);
      }
    }

    function formatRuntime(ms: number): string {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);

      if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      }
      return `${seconds}s`;
    }

    // Run
    main().catch((error) => {
      console.error("[CCO] Fatal error:", error);
      process.exit(1);
    });
    ```
  </action>
  <verify>
    bun run typecheck
    bun run src/index.ts --help
  </verify>
  <done>
    - CLI parses task description and port option
    - --help shows usage information
    - Server starts on specified port
    - PTY spawns claude with task
    - Output streams to stdout with colors
    - Session state transitions correctly
    - SIGINT/SIGTERM trigger graceful shutdown
  </done>
</task>

<task type="auto">
  <name>Task 2: Update package.json bin and scripts</name>
  <files>package.json</files>
  <action>
    Ensure package.json has correct bin entry and scripts:

    ```json
    {
      "bin": {
        "cco": "./src/index.ts"
      },
      "scripts": {
        "start": "bun run src/index.ts",
        "dev": "bun run --watch src/index.ts",
        "typecheck": "tsc --noEmit"
      }
    }
    ```

    Also add shebang check - ensure src/index.ts starts with `#!/usr/bin/env bun`
  </action>
  <verify>
    grep '"cco"' package.json
    head -1 src/index.ts | grep "#!/usr/bin/env bun"
    bun run src/index.ts --help
  </verify>
  <done>
    - package.json has cco bin entry
    - package.json has start, dev, typecheck scripts
    - src/index.ts has bun shebang
    - `bun run start "test"` works
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 foundation:
    - PTY Manager that spawns Claude Code
    - Session Manager with state machine
    - REST API for session info
    - CLI entry point that integrates all components
  </what-built>
  <how-to-verify>
    1. Open terminal in project directory
    2. Run: `bun run src/index.ts "say hello and then exit"`
       - Should see [CCO] startup messages
       - Should see Claude Code output streaming with colors
       - Should see exit code when Claude finishes

    3. While running, open another terminal:
       - Run: `curl http://localhost:3000/api/session`
       - Should see JSON with state: "task_running" and metadata

    4. Test graceful shutdown:
       - Start: `bun run src/index.ts "count to 10 slowly"`
       - Press Ctrl+C before it finishes
       - Should see cleanup message and exit cleanly

    5. Test help:
       - Run: `bun run src/index.ts --help`
       - Should show usage information
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 1, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# Type check
bun run typecheck

# Help works
bun run src/index.ts --help

# API health check (start server first)
# In terminal 1: bun run src/index.ts "test"
# In terminal 2: curl http://localhost:3000/api/health
```
</verification>

<success_criteria>
1. `bun run typecheck` passes
2. `cco --help` shows usage information
3. `cco "task"` spawns Claude Code and streams output
4. Session state transitions: idle -> task_running -> idle
5. GET /api/session returns correct state and metadata
6. Ctrl+C triggers graceful shutdown
7. Exit code from Claude Code is propagated
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-foundation/01-04-SUMMARY.md`
</output>
