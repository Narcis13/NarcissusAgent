---
phase: 03-ai-supervisor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/supervisor/types.ts
  - src/supervisor/spawn.ts
  - src/supervisor/parse.ts
autonomous: true

must_haves:
  truths:
    - "Supervisor types define SupervisorContext with iteration tracking"
    - "spawn() executes claude -p with timeout and captures output"
    - "parseResponse() extracts marker and content from text"
  artifacts:
    - path: "src/supervisor/types.ts"
      provides: "SupervisorContext, SpawnResult, ParsedResponse types"
      exports: ["SupervisorContext", "SpawnResult", "ParsedResponse", "ClaudeSupervisorConfig"]
    - path: "src/supervisor/spawn.ts"
      provides: "Bun.$ wrapper for claude -p execution"
      exports: ["spawnSupervisor"]
    - path: "src/supervisor/parse.ts"
      provides: "Response marker parsing"
      exports: ["parseResponse"]
  key_links:
    - from: "src/supervisor/spawn.ts"
      to: "claude CLI"
      via: "Bun.$ template literal"
      pattern: "\\$`.*claude.*-p"
    - from: "src/supervisor/parse.ts"
      to: "SupervisorAction"
      via: "marker to action mapping"
      pattern: "\\[COMPLETE\\]|\\[ABORT\\]|\\[CONTINUE\\]"
---

<objective>
Create supervisor foundation: types, spawn wrapper, and response parser.

Purpose: Establish the building blocks for Claude-supervising-Claude architecture where `claude -p` is spawned per decision.

Output: Three modules providing type definitions, process spawning, and marker parsing.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-ai-supervisor/03-CONTEXT.md
@.planning/phases/03-ai-supervisor/03-RESEARCH.md
@src/supervisor/index.ts
@src/hooks/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create supervisor types</name>
  <files>src/supervisor/types.ts</files>
  <action>
Create type definitions for the supervisor module:

```typescript
/**
 * Supervisor Types
 *
 * Type definitions for Claude Code CLI supervisor spawning.
 */

/**
 * Context passed to supervisor for decision making
 */
export interface SupervisorContext {
  taskDescription: string;
  toolHistory: ToolHistoryEntry[];
  sessionId: string;
  iterationCount: number;
  maxIterations: number;
}

/**
 * Result from spawning claude -p process
 */
export interface SpawnResult {
  output: string;
  exitCode: number;
  error?: string;
}

/**
 * Parsed supervisor response
 */
export interface ParsedResponse {
  action: 'complete' | 'abort' | 'continue';
  content: string;
  raw: string;
}

/**
 * Configuration for createClaudeSupervisor
 */
export interface ClaudeSupervisorConfig {
  /** Maximum iterations before forced stop (default: 50) */
  maxIterations?: number;
  /** Timeout for supervisor spawn in ms (default: 30000) */
  timeout?: number;
}
```

Import ToolHistoryEntry from hooks/types.ts.
  </action>
  <verify>bun build src/supervisor/types.ts --target=bun</verify>
  <done>types.ts exports SupervisorContext, SpawnResult, ParsedResponse, ClaudeSupervisorConfig</done>
</task>

<task type="auto">
  <name>Task 2: Create spawn wrapper</name>
  <files>src/supervisor/spawn.ts</files>
  <action>
Create Bun.$ wrapper for spawning claude -p:

```typescript
/**
 * Supervisor Spawn
 *
 * Bun shell wrapper for spawning claude -p process.
 */
import { $ } from "bun";
import type { SpawnResult } from "./types";

const DEFAULT_TIMEOUT = 30000;

/**
 * Spawn supervisor Claude Code process with prompt
 *
 * Uses Bun.$ template literal for clean process execution.
 * - .nothrow() prevents exception on non-zero exit
 * - .quiet() suppresses stdout (we capture it)
 * - .timeout() prevents hanging
 *
 * @param prompt - The full supervisor prompt text
 * @param timeout - Timeout in ms (default: 30000)
 * @returns SpawnResult with output, exitCode, and optional error
 */
export async function spawnSupervisor(
  prompt: string,
  timeout: number = DEFAULT_TIMEOUT
): Promise<SpawnResult> {
  const claudeBin = `${process.env.HOME}/.claude/local/claude`;

  try {
    const result = await $`${claudeBin} -p ${prompt} --dangerously-skip-permissions`
      .nothrow()
      .quiet()
      .timeout(timeout);

    return {
      output: result.stdout.toString(),
      exitCode: result.exitCode,
      error: result.exitCode !== 0 ? result.stderr.toString() : undefined,
    };
  } catch (err) {
    // Timeout or other error
    return {
      output: "",
      exitCode: -1,
      error: String(err),
    };
  }
}
```

Key patterns:
- Use Bun.$ template literal (not Bun.spawn)
- Always .nothrow() to handle non-zero exits gracefully
- Always .timeout() to prevent hanging
- Return structured SpawnResult
  </action>
  <verify>bun build src/supervisor/spawn.ts --target=bun</verify>
  <done>spawn.ts exports spawnSupervisor function that invokes claude -p with timeout</done>
</task>

<task type="auto">
  <name>Task 3: Create response parser</name>
  <files>src/supervisor/parse.ts</files>
  <action>
Create marker parsing for supervisor responses:

```typescript
/**
 * Supervisor Response Parser
 *
 * Parses plain text responses with bracketed markers.
 */
import type { ParsedResponse } from "./types";

/**
 * Parse supervisor response for action markers
 *
 * Expected format:
 * - [COMPLETE] followed by summary text
 * - [ABORT] followed by reason text
 * - [CONTINUE] followed by command to inject
 *
 * If no marker found, defaults to 'continue' with warning.
 *
 * @param output - Raw supervisor output text
 * @returns ParsedResponse with action, content, and raw output
 */
export function parseResponse(output: string): ParsedResponse {
  const trimmed = output.trim();

  if (trimmed.startsWith('[COMPLETE]')) {
    return {
      action: 'complete',
      content: trimmed.slice('[COMPLETE]'.length).trim(),
      raw: output,
    };
  }

  if (trimmed.startsWith('[ABORT]')) {
    return {
      action: 'abort',
      content: trimmed.slice('[ABORT]'.length).trim(),
      raw: output,
    };
  }

  if (trimmed.startsWith('[CONTINUE]')) {
    return {
      action: 'continue',
      content: trimmed.slice('[CONTINUE]'.length).trim(),
      raw: output,
    };
  }

  // No marker found - defensive default to continue
  console.warn('[Supervisor] No marker found in response, defaulting to continue');
  return {
    action: 'continue',
    content: trimmed,
    raw: output,
  };
}
```

Key behaviors:
- Case-sensitive marker matching at start of response
- Extracts content after marker (trimmed)
- Preserves raw output for debugging
- Defaults to 'continue' if no marker (defensive)
  </action>
  <verify>bun build src/supervisor/parse.ts --target=bun</verify>
  <done>parse.ts exports parseResponse that extracts marker and content from text</done>
</task>

</tasks>

<verification>
```bash
# All modules compile
bun build src/supervisor/types.ts --target=bun
bun build src/supervisor/spawn.ts --target=bun
bun build src/supervisor/parse.ts --target=bun

# No import errors
bun -e "import { spawnSupervisor } from './src/supervisor/spawn.ts'; import { parseResponse } from './src/supervisor/parse.ts'; console.log('OK')"
```
</verification>

<success_criteria>
1. types.ts exports all four types (SupervisorContext, SpawnResult, ParsedResponse, ClaudeSupervisorConfig)
2. spawn.ts exports spawnSupervisor() that uses Bun.$ with timeout
3. parse.ts exports parseResponse() that handles [COMPLETE], [ABORT], [CONTINUE] markers
4. All modules compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-supervisor/03-01-SUMMARY.md`
</output>
