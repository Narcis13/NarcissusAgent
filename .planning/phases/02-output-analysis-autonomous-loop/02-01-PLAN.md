---
phase: 02-output-analysis-autonomous-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/output/types.ts
  - src/output/buffer.ts
  - src/output/patterns.ts
autonomous: true

must_haves:
  truths:
    - "Output buffer stores last N lines without unbounded growth"
    - "Pattern definitions exist for completion, error, and prompt-ready states"
    - "strip-ansi dependency is installed and importable"
  artifacts:
    - path: "src/output/types.ts"
      provides: "OutputState, PatternMatch, AnalysisResult types"
      exports: ["OutputState", "PatternMatch", "PatternWeight", "AnalysisResult"]
    - path: "src/output/buffer.ts"
      provides: "Ring buffer for output accumulation"
      exports: ["OutputBuffer"]
    - path: "src/output/patterns.ts"
      provides: "Pattern definitions for state detection"
      exports: ["PATTERNS", "PatternCategory"]
  key_links:
    - from: "src/output/patterns.ts"
      to: "src/output/types.ts"
      via: "imports PatternWeight type"
      pattern: "import.*PatternWeight.*from.*types"
---

<objective>
Create foundational output analysis infrastructure: types, ring buffer for output accumulation, and pattern definitions for detecting completion/error/prompt-ready states.

Purpose: This establishes the building blocks for output analysis without the analyzer itself. Buffer and patterns are independent and can be built in parallel conceptually.

Output:
- `src/output/types.ts` - Type definitions
- `src/output/buffer.ts` - OutputBuffer class with ring buffer semantics
- `src/output/patterns.ts` - Pattern definitions with weights
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-output-analysis-autonomous-loop/02-RESEARCH.md

Relevant existing code:
@src/types.ts (re-export hub pattern)
@src/session/types.ts (SessionState, SessionStatus for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strip-ansi dependency and create output types</name>
  <files>package.json, src/output/types.ts</files>
  <action>
1. Run `bun add strip-ansi` to add the ANSI stripping library

2. Create `src/output/types.ts` with these types:

```typescript
/**
 * Output Analysis Types
 *
 * Types for output state detection and confidence scoring.
 */

/** Possible output states detected from terminal output */
export type OutputState = 'running' | 'completed' | 'error' | 'prompt_ready';

/** Categories for pattern classification */
export type PatternCategory = 'completion' | 'error' | 'prompt_ready' | 'running';

/** Weight configuration for a detection pattern */
export interface PatternWeight {
  /** Regex pattern to match against clean (ANSI-stripped) output */
  pattern: RegExp;
  /** Which category this pattern indicates */
  category: PatternCategory;
  /** Contribution to confidence score (0-1) */
  weight: number;
  /** If true, other categories get penalty when this matches */
  exclusive?: boolean;
}

/** Result of matching a single pattern */
export interface PatternMatch {
  /** Name/description of the pattern */
  name: string;
  /** Whether the pattern matched */
  matched: boolean;
  /** Confidence contribution (0-1) */
  confidence: number;
  /** Matched text evidence (empty if no match) */
  evidence: string[];
}

/** Complete analysis result from OutputAnalyzer */
export interface AnalysisResult {
  /** Detected state with highest confidence */
  state: OutputState;
  /** Aggregated confidence score (0-1) */
  confidence: number;
  /** Individual pattern match results */
  matches: PatternMatch[];
  /** ANSI-stripped output used for analysis */
  cleanOutput: string;
  /** Per-category confidence breakdown */
  categoryScores: Map<PatternCategory, number>;
}
```
  </action>
  <verify>
- `bun pm ls | grep strip-ansi` shows strip-ansi installed
- `bunx tsc --noEmit src/output/types.ts` compiles without errors
  </verify>
  <done>strip-ansi installed, output types defined and type-check</done>
</task>

<task type="auto">
  <name>Task 2: Create OutputBuffer with ring buffer semantics</name>
  <files>src/output/buffer.ts</files>
  <action>
Create `src/output/buffer.ts` implementing a ring buffer for output accumulation:

```typescript
/**
 * Output Buffer
 *
 * Fixed-size ring buffer that stores recent terminal output lines.
 * Prevents unbounded memory growth during long-running sessions.
 */

export class OutputBuffer {
  private lines: string[] = [];
  private readonly maxLines: number;

  /**
   * Create a new output buffer
   * @param maxLines Maximum lines to retain (default: 100)
   */
  constructor(maxLines: number = 100) {
    if (maxLines < 1) {
      throw new Error('maxLines must be at least 1');
    }
    this.maxLines = maxLines;
  }

  /**
   * Append text to the buffer, splitting by newlines
   * @param text Raw text to append (may contain multiple lines)
   */
  append(text: string): void {
    // Split on newlines, preserving empty lines
    const newLines = text.split('\n');

    // Handle case where last line didn't end with newline
    // by joining with existing partial line
    if (this.lines.length > 0 && !this.lines[this.lines.length - 1].endsWith('\n')) {
      const partial = this.lines.pop() || '';
      newLines[0] = partial + newLines[0];
    }

    this.lines.push(...newLines);

    // Trim to max size, keeping most recent
    if (this.lines.length > this.maxLines) {
      this.lines = this.lines.slice(-this.maxLines);
    }
  }

  /**
   * Get recent lines from the buffer
   * @param count Number of lines to retrieve (default: 50)
   * @returns Joined string of recent lines
   */
  getRecent(count: number = 50): string {
    const sliceCount = Math.min(count, this.lines.length);
    return this.lines.slice(-sliceCount).join('\n');
  }

  /**
   * Get all buffered lines
   * @returns Joined string of all lines
   */
  getAll(): string {
    return this.lines.join('\n');
  }

  /**
   * Clear the buffer
   */
  clear(): void {
    this.lines = [];
  }

  /**
   * Get current line count
   */
  get length(): number {
    return this.lines.length;
  }

  /**
   * Check if buffer is at capacity
   */
  get isFull(): boolean {
    return this.lines.length >= this.maxLines;
  }
}
```

Key behaviors:
- Handles partial lines (text without trailing newline)
- Automatically trims when over capacity
- Provides getRecent() for getting last N lines
- Thread-safe for single-threaded JS (no async gaps in methods)
  </action>
  <verify>
- `bunx tsc --noEmit src/output/buffer.ts` compiles
- Create quick test: `bun -e "import {OutputBuffer} from './src/output/buffer.ts'; const b = new OutputBuffer(3); b.append('a\nb\nc\nd'); console.log(b.getRecent(2));"` outputs "c\nd"
  </verify>
  <done>OutputBuffer class implements ring buffer semantics with line-aware appending</done>
</task>

<task type="auto">
  <name>Task 3: Create pattern definitions for state detection</name>
  <files>src/output/patterns.ts</files>
  <action>
Create `src/output/patterns.ts` with pattern definitions based on research:

```typescript
/**
 * Pattern Definitions
 *
 * Regex patterns for detecting terminal output states.
 * Based on Claude Code output analysis from research phase.
 *
 * Patterns are categorized and weighted for confidence scoring.
 * Multiple matching patterns increase confidence; contradictions decrease it.
 */

import type { PatternWeight, PatternCategory } from './types.ts';

/**
 * All detection patterns with their categories and weights
 *
 * Weight guidelines:
 * - 0.1-0.2: Weak signal, needs corroboration
 * - 0.3-0.4: Moderate signal
 * - 0.5+: Strong signal (use exclusive flag)
 */
export const PATTERNS: PatternWeight[] = [
  // === COMPLETION PATTERNS ===
  // Strong signals that task is done
  {
    pattern: /(?:I'?ve|I have) (?:finished|completed|done)/i,
    category: 'completion',
    weight: 0.4,
  },
  {
    pattern: /(?:Successfully|Completed) (?:created|updated|fixed|implemented|added)/i,
    category: 'completion',
    weight: 0.3,
  },
  {
    pattern: /What (?:would you like|else|should I)/i,
    category: 'completion',
    weight: 0.35,
  },
  {
    pattern: /Let me know if/i,
    category: 'completion',
    weight: 0.25,
  },
  {
    pattern: /Is there anything else/i,
    category: 'completion',
    weight: 0.3,
  },
  // Exit code 0 is definitive completion
  {
    pattern: /exited? with code:?\s*0/i,
    category: 'completion',
    weight: 0.6,
    exclusive: true,
  },

  // === ERROR PATTERNS ===
  // Signals that something went wrong
  {
    pattern: /(?:Error|Exception|Failed|Failure):/i,
    category: 'error',
    weight: 0.35,
  },
  {
    pattern: /(?:Cannot|Could not|Unable to)/i,
    category: 'error',
    weight: 0.25,
  },
  {
    pattern: /(?:ENOENT|EACCES|EPERM|ENOTFOUND)/i,
    category: 'error',
    weight: 0.4,
  },
  {
    pattern: /command not found/i,
    category: 'error',
    weight: 0.35,
  },
  // Non-zero exit is definitive error
  {
    pattern: /exited? with code:?\s*[1-9]\d*/i,
    category: 'error',
    weight: 0.6,
    exclusive: true,
  },
  {
    pattern: /(?:fatal|critical|panic):/i,
    category: 'error',
    weight: 0.45,
  },

  // === PROMPT READY PATTERNS ===
  // Signals waiting for input
  {
    pattern: /^\s*>\s*$/m,
    category: 'prompt_ready',
    weight: 0.3,
  },
  {
    pattern: /^\s*\$\s*$/m,
    category: 'prompt_ready',
    weight: 0.25,
  },
  {
    pattern: /waiting for (?:input|response)/i,
    category: 'prompt_ready',
    weight: 0.3,
  },
  {
    pattern: /Press (?:Enter|any key)/i,
    category: 'prompt_ready',
    weight: 0.35,
  },

  // === RUNNING PATTERNS ===
  // Signals active work in progress
  {
    pattern: /(?:Reading|Writing|Creating|Updating|Deleting) (?:file|directory)/i,
    category: 'running',
    weight: 0.3,
  },
  {
    pattern: /(?:Running|Executing|Installing|Building)/i,
    category: 'running',
    weight: 0.25,
  },
  {
    pattern: /(?:Analyzing|Processing|Parsing)/i,
    category: 'running',
    weight: 0.2,
  },
  {
    pattern: /\.\.\.\s*$/m,
    category: 'running',
    weight: 0.15,
  },
  {
    pattern: /(?:please wait|in progress)/i,
    category: 'running',
    weight: 0.25,
  },
];

/**
 * Get patterns filtered by category
 */
export function getPatternsByCategory(category: PatternCategory): PatternWeight[] {
  return PATTERNS.filter(p => p.category === category);
}

/**
 * Default confidence threshold for triggering supervisor
 * Based on requirements: 70%
 */
export const DEFAULT_CONFIDENCE_THRESHOLD = 0.7;

/**
 * Categories that should trigger supervisor analysis
 */
export const TRIGGER_CATEGORIES: PatternCategory[] = ['completed', 'error'];
```

Notes:
- Patterns are tuned based on common Claude Code output
- Exclusive patterns penalize other categories when matched
- Running patterns have lower weights (work in progress is normal state)
- Completion and error patterns have higher weights (actionable states)
  </action>
  <verify>
- `bunx tsc --noEmit src/output/patterns.ts` compiles
- Quick test: `bun -e "import {PATTERNS} from './src/output/patterns.ts'; console.log(PATTERNS.length + ' patterns loaded')"` shows pattern count
  </verify>
  <done>Pattern definitions created with categories, weights, and exclusive flags</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx tsc --noEmit` - Full project type check passes
2. `ls src/output/` shows types.ts, buffer.ts, patterns.ts
3. `bun -e "import {OutputBuffer} from './src/output/buffer.ts'; import {PATTERNS} from './src/output/patterns.ts'; console.log('OK')"` - Modules importable
</verification>

<success_criteria>
- strip-ansi dependency installed
- OutputBuffer class accumulates lines with ring buffer semantics
- Pattern definitions cover completion, error, prompt_ready, running states
- All files type-check without errors
- Modules are importable and functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-output-analysis-autonomous-loop/02-01-SUMMARY.md`
</output>
