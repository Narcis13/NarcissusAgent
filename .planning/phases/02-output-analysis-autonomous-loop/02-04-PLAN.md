---
phase: 02-output-analysis-autonomous-loop
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - src/index.ts
  - src/types.ts
autonomous: true

must_haves:
  truths:
    - "CLI integrates LoopController with PTYManager"
    - "PTY output flows through LoopController.processOutput()"
    - "Loop starts when PTY spawns"
    - "Types are re-exported from src/types.ts"
  artifacts:
    - path: "src/index.ts"
      provides: "Integrated CLI with loop controller"
      contains: "new LoopController"
    - path: "src/types.ts"
      provides: "Centralized type re-exports"
      exports: ["LoopController", "OutputAnalyzer", "Cooldown"]
  key_links:
    - from: "src/index.ts"
      to: "src/loop/controller.ts"
      via: "imports and instantiates LoopController"
      pattern: "import.*LoopController.*from.*loop/controller"
    - from: "src/index.ts"
      to: "PTYManager.onData"
      via: "passes data to loop.processOutput()"
      pattern: "loop.*processOutput"
---

<objective>
Integrate LoopController with the existing CLI and PTYManager from Phase 1. Wire output flow through the loop controller for analysis.

Purpose: Connect all Phase 2 components to the existing Phase 1 infrastructure, making the autonomous loop functional (minus the actual supervisor which comes in Phase 3).

Output:
- Updated `src/index.ts` with loop integration
- Updated `src/types.ts` with new exports
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-foundation/01-04-SUMMARY.md

Phase 1 components:
@src/index.ts (current CLI entry point)
@src/types.ts (type re-export hub)

Phase 2 components (from Plans 01-03):
@src/output/types.ts
@src/output/analyzer.ts
@src/output/buffer.ts
@src/loop/types.ts
@src/loop/controller.ts
@src/loop/cooldown.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update type re-exports</name>
  <files>src/types.ts</files>
  <action>
Update `src/types.ts` to re-export Phase 2 types for convenient imports:

Add to existing exports:
```typescript
// Output analysis types
export type {
  OutputState,
  PatternCategory,
  PatternMatch,
  PatternWeight,
  AnalysisResult,
} from './output/types.ts';

export { OutputAnalyzer } from './output/analyzer.ts';
export { OutputBuffer } from './output/buffer.ts';
export { PATTERNS, DEFAULT_CONFIDENCE_THRESHOLD } from './output/patterns.ts';

// Loop types
export type {
  LoopState,
  LoopConfig,
  SupervisorAction,
  SupervisorDecision,
  LoopEventHandler,
  LoopStats,
} from './loop/types.ts';
export { DEFAULT_LOOP_CONFIG } from './loop/types.ts';

export { Cooldown } from './loop/cooldown.ts';
export { LoopController } from './loop/controller.ts';
export type { SupervisorFn } from './loop/controller.ts';
```

Preserve existing PTY and Session exports.
  </action>
  <verify>
- `bunx tsc --noEmit src/types.ts` compiles
- `bun -e "import { LoopController, OutputAnalyzer, Cooldown } from './src/types.ts'; console.log('imports OK')"` works
  </verify>
  <done>All Phase 2 types and classes are re-exported from central types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Integrate LoopController into CLI</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to integrate LoopController with the PTY:

1. Import LoopController:
```typescript
import { LoopController } from './loop/controller.ts';
```

2. Create loop controller instance with event handlers that log to console:
```typescript
const loop = new LoopController(
  {
    confidenceThreshold: 0.7,
    minCooldownMs: 3000,
    maxIterations: 100,
  },
  {
    onAnalysis: (result) => {
      if (result.confidence > 0.5) {
        console.error(`[CCO] Analysis: state=${result.state} confidence=${result.confidence.toFixed(2)}`);
      }
    },
    onSupervisorCall: ({ analysis }) => {
      console.error(`[CCO] Calling supervisor (state=${analysis.state})`);
    },
    onSupervisorDecision: (decision) => {
      console.error(`[CCO] Supervisor decision: ${decision.action} - ${decision.reason}`);
    },
    onInject: (cmd) => {
      console.error(`[CCO] Injecting command: ${cmd}`);
      // TODO: Write to PTY in Phase 3
    },
    onStop: (reason) => {
      console.error(`[CCO] Loop stopped: ${reason}`);
    },
    onError: (err) => {
      console.error(`[CCO] Loop error: ${err.message}`);
    },
  }
);
```

3. Start loop when PTY spawns:
```typescript
// After ptyManager.spawn() call
loop.start(taskDescription);
```

4. Wire PTY output through loop controller:
In the PTYManagerOptions.onData callback, add:
```typescript
onData: (data) => {
  // Existing: write to stdout for display
  process.stdout.write(data);

  // New: feed to loop controller for analysis
  loop.processOutput(data).catch((err) => {
    console.error('[CCO] Process output error:', err);
  });
},
```

5. Stop loop on PTY exit:
In the onExit callback:
```typescript
onExit: (exitCode, signalCode) => {
  // Existing exit handling...

  // Stop the loop
  if (loop.isRunning()) {
    loop.stop(`PTY exited with code ${exitCode}`);
  }
},
```

6. Add --verbose flag to control analysis logging (optional enhancement):
```typescript
const args = parseArgs({
  args: Bun.argv.slice(2),
  options: {
    port: { type: 'string', default: '3000' },
    verbose: { type: 'boolean', default: false },
  },
  strict: false,
  allowPositionals: true,
});
```

Then conditionally log based on verbose flag.
  </action>
  <verify>
- `bunx tsc --noEmit src/index.ts` compiles
- `bun run src/index.ts --help` still shows usage
- Manual test: Run with a simple task and observe analysis logs
  </verify>
  <done>LoopController is integrated with PTYManager - output flows through analysis pipeline</done>
</task>

<task type="auto">
  <name>Task 3: Verify end-to-end integration</name>
  <files>none (verification only)</files>
  <action>
Verify the integration by:

1. Type check the entire project:
```bash
bunx tsc --noEmit
```

2. Run the CLI with help:
```bash
bun run src/index.ts --help
```

3. Check imports work:
```bash
bun -e "
import { LoopController, OutputAnalyzer, PTYManager } from './src/types.ts';
import { createSessionManager } from './src/session/manager.ts';

console.log('All imports resolved');
console.log('LoopController:', typeof LoopController);
console.log('OutputAnalyzer:', typeof OutputAnalyzer);
"
```

4. Verify loop controller is ready:
```bash
bun -e "
import { LoopController } from './src/loop/controller.ts';

const loop = new LoopController();
loop.start('test');
console.log('Loop state:', loop.getState());
console.log('Loop running:', loop.isRunning());
loop.stop('test complete');
console.log('Loop state after stop:', loop.getState());
"
```
  </action>
  <verify>
- All commands above succeed
- Type check passes
- Imports resolve correctly
- Loop controller lifecycle works
  </verify>
  <done>End-to-end integration verified - Phase 2 components are wired into Phase 1 infrastructure</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx tsc --noEmit` - Full project type check
2. `bun test` - All tests pass
3. `bun run src/index.ts --help` - CLI still works
4. Manual verification: Output analysis logs appear when running with a task
</verification>

<success_criteria>
- LoopController instantiated in CLI
- PTY output flows through loop.processOutput()
- Analysis results logged for high-confidence detections
- Loop starts when PTY spawns
- Loop stops when PTY exits
- Type exports consolidated in src/types.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-output-analysis-autonomous-loop/02-04-SUMMARY.md`
</output>
