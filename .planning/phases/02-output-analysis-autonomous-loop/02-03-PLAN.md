---
phase: 02-output-analysis-autonomous-loop
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/loop/types.ts
  - src/loop/cooldown.ts
  - src/loop/controller.ts
autonomous: true

must_haves:
  truths:
    - "Cooldown enforces minimum 2-5 second gap between supervisor calls"
    - "Loop controller orchestrates spawn -> monitor -> detect -> analyze -> inject flow"
    - "Loop stops when supervisor decides work is complete"
    - "Loop prevents feedback loops via cooldown mechanism"
  artifacts:
    - path: "src/loop/types.ts"
      provides: "LoopState, LoopConfig, SupervisorDecision types"
      exports: ["LoopState", "LoopConfig", "SupervisorDecision", "LoopEventHandler"]
    - path: "src/loop/cooldown.ts"
      provides: "Cooldown tracker class"
      exports: ["Cooldown"]
    - path: "src/loop/controller.ts"
      provides: "LoopController orchestration class"
      exports: ["LoopController"]
  key_links:
    - from: "src/loop/controller.ts"
      to: "src/output/analyzer.ts"
      via: "imports OutputAnalyzer"
      pattern: "import.*OutputAnalyzer.*from.*output/analyzer"
    - from: "src/loop/controller.ts"
      to: "src/output/buffer.ts"
      via: "imports OutputBuffer"
      pattern: "import.*OutputBuffer.*from.*output/buffer"
    - from: "src/loop/controller.ts"
      to: "src/session/manager.ts"
      via: "uses SessionManager for state transitions"
      pattern: "sessionManager"
---

<objective>
Implement the autonomous loop infrastructure: cooldown tracker for preventing feedback loops and LoopController for orchestrating the spawn -> monitor -> detect -> analyze flow.

Purpose: This is the autonomous loop skeleton that will be connected to the supervisor in Phase 3. For now, it provides the orchestration without the actual Claude API calls.

Output:
- `src/loop/types.ts` - Type definitions for loop state and config
- `src/loop/cooldown.ts` - Cooldown class for rate limiting
- `src/loop/controller.ts` - LoopController class
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-output-analysis-autonomous-loop/02-RESEARCH.md

Dependencies from Phase 1:
@src/pty/types.ts (PTYManager interface)
@src/session/types.ts (SessionState, SessionStatus)
@src/session/manager.ts (SessionManager)

Dependencies from Plan 01 & 02:
@src/output/types.ts
@src/output/analyzer.ts
@src/output/buffer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create loop types</name>
  <files>src/loop/types.ts</files>
  <action>
Create `src/loop/types.ts` with loop-specific type definitions:

```typescript
/**
 * Loop Types
 *
 * Type definitions for the autonomous loop controller.
 */

import type { AnalysisResult } from '../output/types.ts';

/**
 * Loop controller state
 */
export type LoopState =
  | 'idle'           // Not running
  | 'monitoring'     // Watching PTY output
  | 'analyzing'      // Running pattern analysis
  | 'waiting_cooldown' // Cooldown period before supervisor
  | 'calling_supervisor' // Awaiting supervisor decision
  | 'injecting'      // Writing command to PTY
  | 'stopped';       // Gracefully stopped

/**
 * Configuration for loop behavior
 */
export interface LoopConfig {
  /** Minimum milliseconds between supervisor calls (default: 3000) */
  minCooldownMs: number;
  /** Maximum cooldown in ms - not currently used, for future adaptive cooldown */
  maxCooldownMs: number;
  /** Confidence threshold to trigger supervisor (default: 0.7) */
  confidenceThreshold: number;
  /** Maximum loop iterations before forced stop (default: 100) */
  maxIterations: number;
  /** Output buffer size in lines (default: 100) */
  bufferSize: number;
}

/**
 * Default loop configuration
 */
export const DEFAULT_LOOP_CONFIG: LoopConfig = {
  minCooldownMs: 3000,
  maxCooldownMs: 5000,
  confidenceThreshold: 0.7,
  maxIterations: 100,
  bufferSize: 100,
};

/**
 * Supervisor decision types
 * (Actual supervisor implementation is Phase 3, but types needed for interface)
 */
export type SupervisorAction =
  | 'continue'    // Keep monitoring, no action needed
  | 'inject'      // Inject a new command
  | 'stop'        // Stop the loop (work complete)
  | 'clear'       // Clear terminal and continue
  | 'compact'     // Compact conversation and continue
  | 'abort';      // Abort due to error/issue

/**
 * Decision returned by supervisor
 */
export interface SupervisorDecision {
  /** Action to take */
  action: SupervisorAction;
  /** Command to inject (required if action === 'inject') */
  command?: string;
  /** Reasoning for the decision */
  reason: string;
  /** Supervisor's confidence in this decision */
  confidence: number;
}

/**
 * Event handler callbacks for loop controller
 */
export interface LoopEventHandler {
  /** Called when analysis completes */
  onAnalysis?: (result: AnalysisResult) => void;
  /** Called when supervisor is invoked */
  onSupervisorCall?: (context: { recentOutput: string; analysis: AnalysisResult }) => void;
  /** Called when supervisor returns decision */
  onSupervisorDecision?: (decision: SupervisorDecision) => void;
  /** Called when command is injected */
  onInject?: (command: string) => void;
  /** Called when loop stops */
  onStop?: (reason: string) => void;
  /** Called on loop error */
  onError?: (error: Error) => void;
}

/**
 * Statistics tracked during loop execution
 */
export interface LoopStats {
  /** Number of loop iterations */
  iterations: number;
  /** Number of supervisor calls */
  supervisorCalls: number;
  /** Number of commands injected */
  commandsInjected: number;
  /** Start time */
  startTime: Date;
  /** End time (null if still running) */
  endTime: Date | null;
}
```
  </action>
  <verify>
- `bunx tsc --noEmit src/loop/types.ts` compiles without errors
  </verify>
  <done>Loop types defined including state, config, supervisor decision, and event handlers</done>
</task>

<task type="auto">
  <name>Task 2: Implement Cooldown tracker</name>
  <files>src/loop/cooldown.ts</files>
  <action>
Create `src/loop/cooldown.ts` implementing the cooldown mechanism:

```typescript
/**
 * Cooldown Tracker
 *
 * Enforces minimum time gap between supervisor calls to prevent feedback loops.
 * This is NOT debounce - cooldown starts AFTER an action, not during idle.
 */

export class Cooldown {
  private lastActionTime: number = 0;
  private readonly minMs: number;

  /**
   * Create a cooldown tracker
   * @param minMs Minimum milliseconds between actions (default: 3000)
   */
  constructor(minMs: number = 3000) {
    if (minMs < 0) {
      throw new Error('minMs must be non-negative');
    }
    this.minMs = minMs;
  }

  /**
   * Check if enough time has passed since last action
   * @returns true if cooldown period has elapsed
   */
  canProceed(): boolean {
    const now = Date.now();
    return now - this.lastActionTime >= this.minMs;
  }

  /**
   * Mark an action as taken, starting the cooldown period
   */
  mark(): void {
    this.lastActionTime = Date.now();
  }

  /**
   * Get remaining cooldown time in milliseconds
   * @returns 0 if cooldown elapsed, otherwise remaining ms
   */
  timeRemaining(): number {
    const elapsed = Date.now() - this.lastActionTime;
    return Math.max(0, this.minMs - elapsed);
  }

  /**
   * Wait for cooldown to complete
   * @returns Promise that resolves when cooldown is over
   */
  async wait(): Promise<void> {
    const remaining = this.timeRemaining();
    if (remaining > 0) {
      await new Promise((resolve) => setTimeout(resolve, remaining));
    }
  }

  /**
   * Reset the cooldown (as if no action was ever taken)
   */
  reset(): void {
    this.lastActionTime = 0;
  }

  /**
   * Get the configured minimum cooldown period
   */
  get minCooldownMs(): number {
    return this.minMs;
  }
}
```
  </action>
  <verify>
- `bunx tsc --noEmit src/loop/cooldown.ts` compiles
- Quick test: `bun -e "import {Cooldown} from './src/loop/cooldown.ts'; const c = new Cooldown(100); console.log('canProceed:', c.canProceed()); c.mark(); console.log('after mark:', c.canProceed()); setTimeout(() => console.log('after wait:', c.canProceed()), 150);"` shows cooldown behavior
  </verify>
  <done>Cooldown tracker implements time-based rate limiting with canProceed(), mark(), wait()</done>
</task>

<task type="auto">
  <name>Task 3: Implement LoopController</name>
  <files>src/loop/controller.ts</files>
  <action>
Create `src/loop/controller.ts` - the main orchestration class:

```typescript
/**
 * Loop Controller
 *
 * Orchestrates the autonomous loop: monitor -> detect -> analyze -> (supervisor) -> inject
 *
 * The supervisor call is a placeholder in Phase 2 - actual Claude API integration is Phase 3.
 * For now, the controller provides the infrastructure and can be tested with mock supervisors.
 */

import { OutputAnalyzer } from '../output/analyzer.ts';
import { OutputBuffer } from '../output/buffer.ts';
import { Cooldown } from './cooldown.ts';
import type { AnalysisResult } from '../output/types.ts';
import type {
  LoopState,
  LoopConfig,
  LoopEventHandler,
  LoopStats,
  SupervisorDecision,
  DEFAULT_LOOP_CONFIG,
} from './types.ts';
import { DEFAULT_LOOP_CONFIG as defaultConfig } from './types.ts';

/**
 * Supervisor function type - injected dependency for Phase 3 integration
 */
export type SupervisorFn = (context: {
  taskDescription: string;
  recentOutput: string;
  analysis: AnalysisResult;
}) => Promise<SupervisorDecision>;

export class LoopController {
  private state: LoopState = 'idle';
  private config: LoopConfig;
  private analyzer: OutputAnalyzer;
  private buffer: OutputBuffer;
  private cooldown: Cooldown;
  private stats: LoopStats;
  private eventHandler: LoopEventHandler;
  private supervisorFn: SupervisorFn | null = null;
  private taskDescription: string = '';
  private stopRequested: boolean = false;

  constructor(
    config: Partial<LoopConfig> = {},
    eventHandler: LoopEventHandler = {}
  ) {
    this.config = { ...defaultConfig, ...config };
    this.analyzer = new OutputAnalyzer();
    this.buffer = new OutputBuffer(this.config.bufferSize);
    this.cooldown = new Cooldown(this.config.minCooldownMs);
    this.eventHandler = eventHandler;
    this.stats = this.initStats();
  }

  /**
   * Set the supervisor function (dependency injection for Phase 3)
   */
  setSupervisor(fn: SupervisorFn): void {
    this.supervisorFn = fn;
  }

  /**
   * Start the autonomous loop
   * @param taskDescription Initial task being executed
   */
  start(taskDescription: string): void {
    if (this.state !== 'idle' && this.state !== 'stopped') {
      throw new Error(`Cannot start loop from state: ${this.state}`);
    }

    this.taskDescription = taskDescription;
    this.state = 'monitoring';
    this.stopRequested = false;
    this.stats = this.initStats();
    this.buffer.clear();
    this.cooldown.reset();
  }

  /**
   * Process incoming PTY output
   * Called by PTYManager.onData handler
   *
   * @param data Raw output bytes from PTY
   */
  async processOutput(data: Uint8Array): Promise<void> {
    if (this.state !== 'monitoring') {
      // Not actively monitoring, just buffer the output
      const text = new TextDecoder().decode(data);
      this.buffer.append(text);
      return;
    }

    // Add to buffer
    const text = new TextDecoder().decode(data);
    this.buffer.append(text);

    // Analyze recent output
    this.state = 'analyzing';
    const recentOutput = this.buffer.getRecent(50);
    const analysis = this.analyzer.analyze(recentOutput);

    this.eventHandler.onAnalysis?.(analysis);

    // Check if we should call supervisor
    if (await this.shouldCallSupervisor(analysis)) {
      await this.callSupervisor(analysis);
    } else {
      // Return to monitoring
      this.state = 'monitoring';
    }

    // Check iteration limit
    this.stats.iterations++;
    if (this.stats.iterations >= this.config.maxIterations) {
      this.stop('Max iterations reached');
    }
  }

  /**
   * Determine if supervisor should be called based on analysis and cooldown
   */
  private async shouldCallSupervisor(analysis: AnalysisResult): Promise<boolean> {
    // Check confidence threshold
    if (analysis.confidence < this.config.confidenceThreshold) {
      return false;
    }

    // Only trigger on completion or error states
    if (analysis.state !== 'completed' && analysis.state !== 'error') {
      return false;
    }

    // Check cooldown
    if (!this.cooldown.canProceed()) {
      this.state = 'waiting_cooldown';
      this.eventHandler.onAnalysis?.(analysis); // Notify that we're waiting
      return false;
    }

    return true;
  }

  /**
   * Call the supervisor and handle the decision
   */
  private async callSupervisor(analysis: AnalysisResult): Promise<void> {
    if (!this.supervisorFn) {
      // No supervisor configured - default to stop on completion, continue on error
      const defaultDecision: SupervisorDecision = {
        action: analysis.state === 'completed' ? 'stop' : 'continue',
        reason: 'No supervisor configured - using default behavior',
        confidence: 1.0,
      };
      await this.handleDecision(defaultDecision);
      return;
    }

    this.state = 'calling_supervisor';
    const recentOutput = this.buffer.getRecent(50);

    this.eventHandler.onSupervisorCall?.({ recentOutput, analysis });

    try {
      this.cooldown.mark(); // Start cooldown before async call
      this.stats.supervisorCalls++;

      const decision = await this.supervisorFn({
        taskDescription: this.taskDescription,
        recentOutput,
        analysis,
      });

      this.eventHandler.onSupervisorDecision?.(decision);
      await this.handleDecision(decision);
    } catch (error) {
      this.eventHandler.onError?.(error as Error);
      this.state = 'monitoring'; // Resume monitoring on error
    }
  }

  /**
   * Handle supervisor decision
   */
  private async handleDecision(decision: SupervisorDecision): Promise<void> {
    switch (decision.action) {
      case 'inject':
        if (!decision.command) {
          throw new Error('inject action requires command');
        }
        this.state = 'injecting';
        this.eventHandler.onInject?.(decision.command);
        this.stats.commandsInjected++;
        // Note: Actual PTY write is handled by caller
        this.state = 'monitoring';
        break;

      case 'stop':
        this.stop(decision.reason);
        break;

      case 'abort':
        this.stop(`Aborted: ${decision.reason}`);
        break;

      case 'continue':
      case 'clear':
      case 'compact':
        // Return to monitoring
        this.state = 'monitoring';
        break;
    }
  }

  /**
   * Request graceful stop
   */
  stop(reason: string): void {
    this.state = 'stopped';
    this.stats.endTime = new Date();
    this.stopRequested = true;
    this.eventHandler.onStop?.(reason);
  }

  /**
   * Get current loop state
   */
  getState(): LoopState {
    return this.state;
  }

  /**
   * Get loop statistics
   */
  getStats(): LoopStats {
    return { ...this.stats };
  }

  /**
   * Check if loop is actively running
   */
  isRunning(): boolean {
    return this.state !== 'idle' && this.state !== 'stopped';
  }

  /**
   * Get the output buffer (for external access to recent output)
   */
  getBuffer(): OutputBuffer {
    return this.buffer;
  }

  /**
   * Get the analyzer (for external access to analysis capabilities)
   */
  getAnalyzer(): OutputAnalyzer {
    return this.analyzer;
  }

  /**
   * Initialize stats for a new loop run
   */
  private initStats(): LoopStats {
    return {
      iterations: 0,
      supervisorCalls: 0,
      commandsInjected: 0,
      startTime: new Date(),
      endTime: null,
    };
  }
}
```

Key behaviors:
- Dependency injection for supervisor (Phase 3 provides actual implementation)
- Cooldown prevents rapid supervisor calls
- Event handlers allow external observation
- Stats tracking for debugging and monitoring
- Graceful stop mechanism
  </action>
  <verify>
- `bunx tsc --noEmit src/loop/controller.ts` compiles
- Quick integration test:
```bash
bun -e "
import { LoopController } from './src/loop/controller.ts';

const loop = new LoopController({}, {
  onAnalysis: (r) => console.log('Analysis:', r.state, r.confidence),
  onStop: (r) => console.log('Stopped:', r)
});

loop.start('test task');
console.log('State:', loop.getState());

// Simulate output
const encoder = new TextEncoder();
loop.processOutput(encoder.encode('Running some task...'));
loop.processOutput(encoder.encode('I\\'ve finished the work.'));

console.log('Stats:', loop.getStats());
"
```
  </verify>
  <done>LoopController orchestrates the autonomous loop with cooldown, analysis, and supervisor integration point</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx tsc --noEmit` - Full project type check passes
2. `ls src/loop/` shows types.ts, cooldown.ts, controller.ts
3. Integration test:
```bash
bun -e "
import { LoopController } from './src/loop/controller.ts';
import { Cooldown } from './src/loop/cooldown.ts';

// Test cooldown
const cd = new Cooldown(100);
console.log('Cooldown test:', cd.canProceed() === true);

// Test controller
const ctrl = new LoopController({ confidenceThreshold: 0.3 });
ctrl.start('test');
console.log('Controller started:', ctrl.isRunning());
"
```
</verification>

<success_criteria>
- Cooldown class enforces time-based rate limiting
- LoopController starts, processes output, triggers analysis
- Controller respects confidence threshold before calling supervisor
- Controller respects cooldown before calling supervisor
- Loop can be stopped gracefully
- Event handlers are called at appropriate times
</success_criteria>

<output>
After completion, create `.planning/phases/02-output-analysis-autonomous-loop/02-03-SUMMARY.md`
</output>
