---
phase: 02-output-analysis-autonomous-loop
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/output/analyzer.ts
  - src/output/analyzer.test.ts
autonomous: true

must_haves:
  truths:
    - "Analyzer strips ANSI codes before pattern matching"
    - "Analyzer returns confidence score between 0 and 1"
    - "Analyzer detects completion state with 70%+ confidence on clear completion signals"
    - "Analyzer detects error state when error patterns match"
    - "Contradicting patterns reduce confidence"
  artifacts:
    - path: "src/output/analyzer.ts"
      provides: "OutputAnalyzer class for state detection"
      exports: ["OutputAnalyzer"]
    - path: "src/output/analyzer.test.ts"
      provides: "Tests for analyzer behavior"
      min_lines: 50
  key_links:
    - from: "src/output/analyzer.ts"
      to: "src/output/patterns.ts"
      via: "imports PATTERNS array"
      pattern: "import.*PATTERNS.*from.*patterns"
    - from: "src/output/analyzer.ts"
      to: "strip-ansi"
      via: "imports stripAnsi function"
      pattern: "import stripAnsi from 'strip-ansi'"
---

<objective>
Implement OutputAnalyzer using TDD - the core component that strips ANSI codes, runs pattern matching, and calculates confidence scores for state detection.

Purpose: This is the brain of output analysis. It takes raw terminal output and produces actionable state detection with confidence scores. TDD ensures the confidence calculation logic is correct.

Output:
- `src/output/analyzer.ts` - OutputAnalyzer class
- `src/output/analyzer.test.ts` - Test suite
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-output-analysis-autonomous-loop/02-RESEARCH.md

Dependencies from Plan 01:
@src/output/types.ts
@src/output/patterns.ts
</context>

<feature>
  <name>OutputAnalyzer with Confidence Scoring</name>
  <files>src/output/analyzer.ts, src/output/analyzer.test.ts</files>
  <behavior>
The analyzer takes raw terminal output and returns an AnalysisResult:

1. Strip ANSI codes using strip-ansi
2. Run all patterns against clean output
3. Aggregate matches by category
4. Calculate confidence using weighted scoring
5. Determine state from highest-scoring category
6. Apply penalties for contradicting patterns

Test cases (input -> expected):
- "I've finished the task" -> state: 'completed', confidence >= 0.3
- "Error: file not found" -> state: 'error', confidence >= 0.3
- "\x1b[32mI've completed\x1b[0m" -> strips ANSI, state: 'completed'
- "Running..." with "Error:" -> error wins if error weight higher
- No matches -> state: 'running', confidence: 0
- "exited with code: 0" -> state: 'completed', confidence >= 0.5 (exclusive)
- "exited with code: 1" -> state: 'error', confidence >= 0.5 (exclusive)
  </behavior>
  <implementation>
OutputAnalyzer class with:
- constructor(): Initialize with PATTERNS
- analyze(rawOutput: string): AnalysisResult
- private matchPatterns(cleanOutput: string): PatternMatch[]
- private calculateCategoryScores(matches: PatternMatch[]): Map<PatternCategory, number>
- private determineState(scores: Map<PatternCategory, number>): OutputState
- private applyExclusivePenalties(matches: PatternMatch[], scores: Map): void

Confidence calculation:
- Sum weights of matching patterns per category
- Cap at 1.0 per category
- When exclusive pattern matches, penalize other categories by 0.2
- State is category with highest score
- Overall confidence is the winning category's score
  </implementation>
</feature>

<tdd_cycle>

<red>
Create test file first with failing tests:

```typescript
// src/output/analyzer.test.ts
import { describe, test, expect } from 'bun:test';
import { OutputAnalyzer } from './analyzer.ts';

describe('OutputAnalyzer', () => {
  const analyzer = new OutputAnalyzer();

  describe('ANSI stripping', () => {
    test('strips ANSI codes before matching', () => {
      const result = analyzer.analyze('\x1b[32mI\'ve finished\x1b[0m');
      expect(result.cleanOutput).toBe("I've finished");
      expect(result.state).toBe('completed');
    });

    test('handles complex ANSI sequences', () => {
      const result = analyzer.analyze('\x1b[1;31mError:\x1b[0m something failed');
      expect(result.cleanOutput).toBe('Error: something failed');
    });
  });

  describe('completion detection', () => {
    test('detects "I\'ve finished" as completed', () => {
      const result = analyzer.analyze("I've finished the task");
      expect(result.state).toBe('completed');
      expect(result.confidence).toBeGreaterThanOrEqual(0.3);
    });

    test('detects "Successfully created" as completed', () => {
      const result = analyzer.analyze('Successfully created the file');
      expect(result.state).toBe('completed');
    });

    test('detects exit code 0 as completed with high confidence', () => {
      const result = analyzer.analyze('Process exited with code: 0');
      expect(result.state).toBe('completed');
      expect(result.confidence).toBeGreaterThanOrEqual(0.5);
    });
  });

  describe('error detection', () => {
    test('detects "Error:" as error', () => {
      const result = analyzer.analyze('Error: file not found');
      expect(result.state).toBe('error');
      expect(result.confidence).toBeGreaterThanOrEqual(0.3);
    });

    test('detects exit code 1 as error with high confidence', () => {
      const result = analyzer.analyze('Process exited with code: 1');
      expect(result.state).toBe('error');
      expect(result.confidence).toBeGreaterThanOrEqual(0.5);
    });

    test('detects ENOENT as error', () => {
      const result = analyzer.analyze('ENOENT: no such file');
      expect(result.state).toBe('error');
    });
  });

  describe('confidence scoring', () => {
    test('multiple matching patterns increase confidence', () => {
      const singleMatch = analyzer.analyze("I've finished");
      const multiMatch = analyzer.analyze("I've finished. What would you like next?");
      expect(multiMatch.confidence).toBeGreaterThan(singleMatch.confidence);
    });

    test('confidence is capped at 1.0', () => {
      const result = analyzer.analyze(
        "I've finished. Successfully created. What would you like? Let me know if needed."
      );
      expect(result.confidence).toBeLessThanOrEqual(1.0);
    });

    test('no matches returns running state with 0 confidence', () => {
      const result = analyzer.analyze('some random text');
      expect(result.state).toBe('running');
      expect(result.confidence).toBe(0);
    });
  });

  describe('exclusive patterns', () => {
    test('exit code 0 penalizes error category', () => {
      const result = analyzer.analyze('Error: something\nexited with code: 0');
      // Exit code 0 is exclusive for completion, should win over error
      expect(result.state).toBe('completed');
    });

    test('exit code 1 penalizes completion category', () => {
      const result = analyzer.analyze("I've finished\nexited with code: 1");
      // Exit code 1 is exclusive for error, should win
      expect(result.state).toBe('error');
    });
  });

  describe('category scores', () => {
    test('provides per-category breakdown', () => {
      const result = analyzer.analyze("I've finished");
      expect(result.categoryScores).toBeDefined();
      expect(result.categoryScores.get('completion')).toBeGreaterThan(0);
    });
  });
});
```

Run tests - they should fail (analyzer doesn't exist yet):
```bash
bun test src/output/analyzer.test.ts
```
</red>

<green>
Implement OutputAnalyzer to make tests pass:

```typescript
// src/output/analyzer.ts
/**
 * Output Analyzer
 *
 * Analyzes terminal output to detect task state (completion, error, etc.)
 * using pattern matching and confidence scoring.
 */

import stripAnsi from 'strip-ansi';
import { PATTERNS } from './patterns.ts';
import type {
  OutputState,
  PatternCategory,
  PatternMatch,
  AnalysisResult,
} from './types.ts';

/** Penalty applied to other categories when exclusive pattern matches */
const EXCLUSIVE_PENALTY = 0.2;

export class OutputAnalyzer {
  /**
   * Analyze terminal output and determine state with confidence
   *
   * @param rawOutput Raw terminal output (may include ANSI codes)
   * @returns Analysis result with state, confidence, and match details
   */
  analyze(rawOutput: string): AnalysisResult {
    // Strip ANSI codes for pattern matching
    const cleanOutput = stripAnsi(rawOutput);

    // Match all patterns
    const matches = this.matchPatterns(cleanOutput);

    // Calculate per-category scores
    const categoryScores = this.calculateCategoryScores(matches);

    // Apply penalties for exclusive patterns
    this.applyExclusivePenalties(matches, categoryScores);

    // Determine winning state
    const state = this.determineState(categoryScores);

    // Overall confidence is the winning category's score
    const confidence = categoryScores.get(
      state === 'running' ? 'running' : (state as PatternCategory)
    ) ?? 0;

    return {
      state,
      confidence,
      matches,
      cleanOutput,
      categoryScores,
    };
  }

  /**
   * Match all patterns against clean output
   */
  private matchPatterns(cleanOutput: string): PatternMatch[] {
    return PATTERNS.map((pw) => {
      const match = pw.pattern.exec(cleanOutput);
      return {
        name: pw.pattern.source,
        matched: match !== null,
        confidence: match !== null ? pw.weight : 0,
        evidence: match ? [match[0]] : [],
      };
    });
  }

  /**
   * Calculate scores per category by summing matched pattern weights
   */
  private calculateCategoryScores(
    matches: PatternMatch[]
  ): Map<PatternCategory, number> {
    const scores = new Map<PatternCategory, number>([
      ['completion', 0],
      ['error', 0],
      ['prompt_ready', 0],
      ['running', 0],
    ]);

    PATTERNS.forEach((pw, index) => {
      if (matches[index].matched) {
        const current = scores.get(pw.category) ?? 0;
        // Cap at 1.0
        scores.set(pw.category, Math.min(1.0, current + pw.weight));
      }
    });

    return scores;
  }

  /**
   * Apply penalties when exclusive patterns match
   */
  private applyExclusivePenalties(
    matches: PatternMatch[],
    scores: Map<PatternCategory, number>
  ): void {
    PATTERNS.forEach((pw, index) => {
      if (matches[index].matched && pw.exclusive) {
        // Penalize all other categories
        for (const [category, score] of scores) {
          if (category !== pw.category) {
            scores.set(category, Math.max(0, score - EXCLUSIVE_PENALTY));
          }
        }
      }
    });
  }

  /**
   * Determine state from category scores
   * Returns 'running' if no significant matches
   */
  private determineState(scores: Map<PatternCategory, number>): OutputState {
    let maxScore = 0;
    let maxCategory: PatternCategory = 'running';

    for (const [category, score] of scores) {
      if (score > maxScore) {
        maxScore = score;
        maxCategory = category;
      }
    }

    // If no patterns matched, default to 'running'
    if (maxScore === 0) {
      return 'running';
    }

    // Map pattern category to output state
    // 'prompt_ready' maps to OutputState 'prompt_ready'
    // others map directly
    return maxCategory as OutputState;
  }
}
```

Run tests - they should pass:
```bash
bun test src/output/analyzer.test.ts
```
</green>

<refactor>
If tests pass, review for cleanup opportunities:
- Extract constants (EXCLUSIVE_PENALTY)
- Add JSDoc comments
- Ensure consistent error handling

No major refactoring expected - implementation is straightforward.

Commit after refactor if changes made.
</refactor>

</tdd_cycle>

<verification>
1. `bun test src/output/analyzer.test.ts` - All tests pass
2. `bunx tsc --noEmit` - Project type-checks
3. Coverage check: `bun test --coverage src/output/analyzer.test.ts`
</verification>

<success_criteria>
- All test cases pass
- Analyzer strips ANSI codes correctly
- Confidence scores are in range [0, 1]
- Completion detected at 70%+ confidence for clear signals
- Error detection works for common patterns
- Exclusive patterns properly penalize other categories
</success_criteria>

<output>
After completion, create `.planning/phases/02-output-analysis-autonomous-loop/02-02-SUMMARY.md`
</output>
